import os
import subprocess
import logging
import uuid
import tempfile
import base64

logger = logging.getLogger('metasploit')

TEMP_DIR = os.path.join(tempfile.gettempdir(), 'redteaming-toolkit', 'payloads')
os.makedirs(TEMP_DIR, exist_ok=True)

class MetasploitModule:
    def __init__(self):
        # Inizializzazione con percorsi predefiniti per Metasploit
        self.msf_paths = [
            '/usr/local/bin/msfvenom',
            '/opt/metasploit-framework/msfvenom',
            '/usr/bin/msfvenom',
            '/usr/share/metasploit-framework/msfvenom'
        ]
    
    def generate_payload(self, payload_type, options):
        """
        Genera un payload standalone utilizzando msfvenom
        
        Args:
            payload_type (str): Tipo di payload (es. windows/x64/meterpreter/reverse_tcp)
            options (dict): Opzioni del payload (es. LHOST, LPORT, ecc.)
            
        Returns:
            dict: Risultato dell'operazione
        """
        # Verifica che il payload sia supportato
        safe_payload = False
        safe_types = ["meterpreter", "shell_reverse_tcp", "reverse_tcp", "bind_tcp"]
        for safe_type in safe_types:
            if safe_type in payload_type.lower():
                safe_payload = True
                break
                
        if not safe_payload:
            return {
                'status': 'error', 
                'message': 'Questo payload potrebbe richiedere parametri aggiuntivi non supportati. Utilizzare solo payload di tipo meterpreter, reverse_tcp o bind_tcp.'
            }
        
        # Genera un ID univoco per il payload
        payload_id = str(uuid.uuid4())
        
        # Determina il formato del file in base al tipo di payload
        if 'windows' in payload_type.lower():
            file_extension = 'exe'
            format_type = 'exe'
        elif 'linux' in payload_type.lower():
            file_extension = 'elf'
            format_type = 'elf'
        elif 'osx' in payload_type.lower() or 'macos' in payload_type.lower():
            file_extension = 'macho'
            format_type = 'macho'
        else:
            # Formato di fallback per tipi non riconosciuti
            file_extension = 'bin'
            format_type = 'raw'
        
        # Assicurati che la directory temporanea esista
        os.makedirs(TEMP_DIR, exist_ok=True)
        
        # Costruisci il nome del file temporaneo
        filename = f"{payload_id}.{file_extension}"
        temp_output_path = os.path.join(TEMP_DIR, filename)
        
        # Trova il percorso eseguibile di msfvenom
        msfvenom_path = 'msfvenom'  
        for path in self.msf_paths:
            if os.path.exists(path):
                msfvenom_path = path
                break
        
        # Aggiungi i parametri automaticamente in base al tipo di payload
        self._add_required_parameters(payload_type, options)
        
        # Costruisci il comando msfvenom
        cmd = [msfvenom_path, '-p', payload_type]
        
        # Aggiungi le opzioni
        for key, value in options.items():
            if key not in ['encoder', 'iterations']:  
                cmd.append(f"{key}={value}")
        
        # Aggiungi il formato e il percorso di output
        cmd.append('-f')
        cmd.append(format_type)
        
        # Aggiungi opzioni di offuscamento se presenti
        if 'encoder' in options and options['encoder']:
            cmd.append('-e')
            cmd.append(options['encoder'])
            
            if 'iterations' in options and options['iterations']:
                cmd.append('-i')
                cmd.append(str(options['iterations']))
        
        # Aggiungi il percorso di output
        cmd.append('-o')
        cmd.append(temp_output_path)
        
        try:
            # Esegui il comando
            logger.info(f"Generating payload with command: {' '.join(cmd)}")
            result = subprocess.run(cmd, 
                                   stdout=subprocess.PIPE, 
                                   stderr=subprocess.PIPE, 
                                   text=True, 
                                   check=False)
            
            if result.returncode != 0:
                return {
                    'status': 'error', 
                    'message': f"Error generating payload"
                }
            
            # Leggi il contenuto binario del file
            with open(temp_output_path, 'rb') as f:
                payload_binary = f.read()
                
            logger.info(f"Payload binary size: {len(payload_binary)} bytes")
            
            # Codifica il payload in base64
            try:
                payload_base64 = base64.b64encode(payload_binary).decode('utf-8')
                logger.info(f"Base64 encoding successful, size: {len(payload_base64)}")
            except Exception as enc_err:
                logger.error(f"Error encoding payload to base64: {str(enc_err)}")
                return {
                    'status': 'error',
                    'message': f'Errore nella codifica del payload: {str(enc_err)}'
                }
            
            # Elimina il file temporaneo
            if os.path.exists(temp_output_path):
                os.remove(temp_output_path)
                logger.info(f"Temporary file removed: {temp_output_path}")
                
            mime_type = self._get_mime_type(file_extension)
            logger.info(f"Returning payload with MIME type: {mime_type}")
                
            return {
                'status': 'success',
                'payload_id': payload_id,
                'filename': filename,
                'payload_data': payload_base64,
                'mime_type': mime_type,
                'output': result.stdout
            }
        except Exception as e:
            logger.error(f"Exception generating payload: {str(e)}")
            
            # Pulisce eventuali file temporanei in caso di errore
            if os.path.exists(temp_output_path):
                os.remove(temp_output_path)
                
            return {'status': 'error', 'message': str(e)}
    
    def _add_required_parameters(self, payload_type, options):
        """
        Aggiunge automaticamente i parametri necessari in base al tipo di payload
        
        Args:
            payload_type (str): Tipo di payload
            options (dict): Opzioni attuali del payload
        """
        # Parametri per payload di tipo reverse
        if 'reverse' in payload_type.lower():
            if 'LHOST' not in options:
                options['LHOST'] = '127.0.0.1'  
            if 'LPORT' not in options:
                options['LPORT'] = '4444'  
                
        # Parametri per payload di tipo bind
        elif 'bind' in payload_type.lower():
            if 'LPORT' not in options:
                options['LPORT'] = '4444'  
            
            # Parametri specifici per bind_hidden_tcp
            if 'bind_hidden_tcp' in payload_type.lower():
                if 'AHOST' not in options:
                    options['AHOST'] = '127.0.0.1'  
        
        # Parametri specifici per Windows
        if 'windows' in payload_type.lower():
            # Aggiungi parametri specifici per payload Windows
            if 'powershell' in payload_type.lower():
                if 'PAYLOAD_DATA' not in options:
                    options['PAYLOAD_DATA'] = 'calc.exe'  
            if 'reflective' in payload_type.lower():
                if 'EXITFUNC' not in options:
                    options['EXITFUNC'] = 'thread'
            # Parametri per patchupmeterpreter
            if 'patchupmeterpreter' in payload_type.lower():
                if 'EXITFUNC' not in options:
                    options['EXITFUNC'] = 'thread'
        
        # Parametri specifici per Linux
        elif 'linux' in payload_type.lower():
            # Aggiungi parametri specifici per payload Linux
            if 'shell' in payload_type.lower():
                if 'PrependSetuid' not in options:
                    options['PrependSetuid'] = 'false'
        
        # Parametri specifici per macOS
        elif 'osx' in payload_type.lower() or 'macos' in payload_type.lower():
            # Aggiungi parametri specifici per payload macOS
            if 'x64' in payload_type.lower():
                if 'EXITFUNC' not in options:
                    options['EXITFUNC'] = 'thread'
            if 'shell' in payload_type.lower():
                if 'DYLD_LIBRARY_PATH' not in options:
                    options['DYLD_LIBRARY_PATH'] = '/usr/lib:/usr/local/lib'
        
        # Parametri per payload specifici
        if 'meterpreter' in payload_type.lower():
            if 'SessionCommunicationTimeout' not in options:
                options['SessionCommunicationTimeout'] = '300'
        elif 'shellcode' in payload_type.lower():
            if 'BadChars' not in options:
                options['BadChars'] = '\\x00\\x0a\\x0d' 
        
        # Aggiungi altri parametri in base al tipo di encoder
        if 'encoder' in options and options['encoder']:
            if 'shikata_ga_nai' in options['encoder'].lower():
                if 'EncoderOptions' not in options:
                    options['EncoderOptions'] = 'BufferRegister=EAX'
    
    def _get_mime_type(self, extension):
        """Restituisce il MIME type appropriato per l'estensione del file"""
        mime_map = {
            'exe': 'application/vnd.microsoft.portable-executable',
            'elf': 'application/x-executable',
            'macho': 'application/x-mach-binary',
            'bin': 'application/octet-stream',
            'apk': 'application/vnd.android.package-archive',
            'asp': 'text/asp',
            'aspx': 'text/aspx',
            'bash': 'text/x-shellscript',
            'java': 'application/java-archive',
            'js_be': 'text/javascript',
            'js_le': 'text/javascript',
            'php': 'application/x-php',
            'ps1': 'text/plain',
            'py': 'text/x-python',
            'raw': 'application/octet-stream',
            'vba': 'text/plain',
            'vbs': 'text/vbscript'
        }
        return mime_map.get(extension, 'application/octet-stream')
    
    def get_available_payloads(self):
        """Restituisce i payload disponibili in msfvenom"""
        # Trova il percorso eseguibile di msfvenom
        msfvenom_path = 'msfvenom'  
        for path in self.msf_paths:
            if os.path.exists(path):
                msfvenom_path = path
                break
        
        try:
            result = subprocess.run([msfvenom_path, '--list', 'payloads'], 
                                   stdout=subprocess.PIPE, 
                                   stderr=subprocess.PIPE, 
                                   text=True, 
                                   check=False)
            
            if result.returncode != 0:
                logger.error(f"Error listing payloads: {result.stderr}")
                return []
                
            # Parsing dell'output per estrarre i payload
            payloads = []
            lines = result.stdout.split('\n')
            
            # Lista di payload da filtrare perché richiedono parametri speciali
            excluded_payloads = [
                "/custom/",      
                "_ipknock",      
                "_bind_nonx",    
                "_seh_",         
                "_alloc_",       
                "_ord_",         
                "generic/",      
                "/dllinject/",   
                "/reflectivedll",
                "/peinject/",    
                "/upexec/",      
                "/exec",         
                "/shell/",       
                "download_exec", 
                "upload_exec",   
                "inject",        
                "migrate",       
                "pingback",      
                "reverse_http",  
                "reverse_winhttp",
                "vncinject",     
                "adduser",       
                "loadlibrary",   
                "tcp_uuid",      
                "udp_uuid",      
                "format",      
                "file_dropper",
                "registry",    
                "powershell",  
                "reflection",  
                "osx/isight",  
                "droplnk",     
                "encrypted",   
                "rc4",           
                "cve-"         
            ]
            
            # Lista di payload sicuri che richiedono solo LHOST/LPORT
            safe_payload_types = [
                "meterpreter",
                "shell_reverse_tcp",
                "reverse_tcp",
                "bind_tcp"
            ]
            
            for line in lines:
                if '/' in line and not line.startswith('='):
                    parts = line.strip().split()
                    if parts:
                        payload_name = parts[0]
                        
                        # Verifica se il payload è nella lista di esclusione
                        should_exclude = False
                        for excluded in excluded_payloads:
                            if excluded in payload_name.lower():
                                should_exclude = True
                                break
                        
                        # Se il payload non è nella lista di esclusione, verifica se è sicuro
                        if not should_exclude:
                            # Includi solo i payload che sappiamo essere sicuri
                            is_safe = False
                            for safe_type in safe_payload_types:
                                if safe_type in payload_name.lower():
                                    is_safe = True
                                    break
                            
                            if is_safe:
                                payloads.append(payload_name)
            
            # Ordina i payload per rendere più facile la selezione
            payloads.sort()
            
            # Log del numero di payload filtrati
            logger.info(f"Filtered to {len(payloads)} safe payloads that require only LHOST/LPORT")
            
            return payloads
        except Exception as e:
            logger.error(f"Exception listing payloads: {str(e)}")
            return []
    
    def get_available_encoders(self):
        """Restituisce gli encoder disponibili in msfvenom"""
        # Trova il percorso eseguibile di msfvenom
        msfvenom_path = 'msfvenom'  # Default
        for path in self.msf_paths:
            if os.path.exists(path):
                msfvenom_path = path
                break
                
        try:
            result = subprocess.run([msfvenom_path, '--list', 'encoders'], 
                                   stdout=subprocess.PIPE, 
                                   stderr=subprocess.PIPE, 
                                   text=True, 
                                   check=False)
            
            if result.returncode != 0:
                logger.error(f"Error listing encoders: {result.stderr}")
                return []
                
            # Parsing dell'output per estrarre gli encoder
            encoders = []
            lines = result.stdout.split('\n')
            for line in lines:
                if '/' in line and not line.startswith('='):
                    parts = line.strip().split()
                    if parts:
                        encoders.append({
                            'name': parts[0],
                            'description': ' '.join(parts[1:]) if len(parts) > 1 else ''
                        })
            
            return encoders
        except Exception as e:
            logger.error(f"Exception listing encoders: {str(e)}")
            return []
    
    def get_available_formats(self):
        """Restituisce i formati di output disponibili in msfvenom"""
        # Lista dei formati comuni
        return [
            {'name': 'exe', 'description': 'Windows Executable'},
            {'name': 'elf', 'description': 'Linux Executable'},
            {'name': 'macho', 'description': 'Mac OS X Executable'},
            {'name': 'apk', 'description': 'Android Package'},
            {'name': 'asp', 'description': 'ASP Script'},
            {'name': 'aspx', 'description': 'ASPX Script'},
            {'name': 'bash', 'description': 'Bash Script'},
            {'name': 'java', 'description': 'Java Class File'},
            {'name': 'js_be', 'description': 'JavaScript (Big Endian)'},
            {'name': 'js_le', 'description': 'JavaScript (Little Endian)'},
            {'name': 'php', 'description': 'PHP Script'},
            {'name': 'ps1', 'description': 'PowerShell Script'},
            {'name': 'py', 'description': 'Python Script'},
            {'name': 'raw', 'description': 'Raw Shellcode'},
            {'name': 'vba', 'description': 'VBA Script'},
            {'name': 'vbs', 'description': 'VBS Script'}
        ] 